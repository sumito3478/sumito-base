package info.sumito3478.math

object Fixed32 {
  type V = Int

  type Repr = Fixed32
  
  val base = 8
  
  val valueOps = Numeric.IntIsIntegral
  
  /* start of boilerplate codes. 
   * would probably be generated by macro in the future.
   */
  
  val companion = this
  
  trait IsNumeric extends FixedIsNumeric[Repr, V] {
    val base = companion.base
    
    val valueOps = companion.valueOps
    
    def toV(r: Repr): V = {
      r.intern
    }
    
    def toRepr(v: V): Repr = {
      new Repr(v)
    }
  }
  
  object IsNumeric extends IsNumeric
  
  object IsFractional extends IsNumeric with FixedIsFractional[Repr, V]
  
  object AsIfIntegral extends IsNumeric with FixedAsIfIntegral[Repr, V]
  
  object Ordering extends Ordering[Repr] {
    def compare(x: Repr, y: Repr): Int = {
      IsNumeric.compare(x, y)
    }
  }
  
  def apply(integer: V, decimal: V): Repr = {
    IsFractional(integer, decimal)
  }
}

import Fixed32.companion
import companion.V

class Fixed32(val intern: V) extends FixedNumberLike[Fixed32, V] {
  import companion.Repr
  
  def num: Fractional[Repr] = companion.IsFractional
  
  def integralNum: Integral[Repr] = companion.AsIfIntegral
  
  def self: Repr = this
  
  def ord: Ordering[Repr] = companion.Ordering
}  